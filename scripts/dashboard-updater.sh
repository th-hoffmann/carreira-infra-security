#!/usr/bin/env bash

# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë  üîÑ dashboard-updater.sh
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
# 
# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë üìã INFORMA√á√ïES DO SCRIPT
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
# 
#   üìÑ Descri√ß√£o.....: Atualiza o DASHBOARD_KPIS.md com m√©tricas reais extra√≠das
#    das issues do GitHub, integrando com o weekly-report.sh. Inclui sistema
#    automatizado de backup com pol√≠tica de reten√ß√£o de 7 arquivos.
#
#   üë®‚Äçüíª Desenvolvedor.: Thiago Hoffmann
#   üìÆ Contato.......: thiago@hoffmann.tec.br
#   üîó GitHub........: https://github.com/th-hoffmann
#   üåê LinkedIn......: https://linkedin.com/in/th-hoffmann87
#
#   üìÖ Data..........: 26/08/2025
#   üè∑Ô∏è  Vers√£o.......: 1.1.1
#   
#   üîß Melhorias v1.1.1:
#   - ‚úÖ Corre√ß√µes de boas pr√°ticas: declara√ß√£o separada de vari√°veis
#   - ‚úÖ Melhor tratamento de erros e robustez do c√≥digo
#   - ‚úÖ Conformidade total com shellcheck (zero warnings)
#   
#   üîß Melhorias v1.1.0:
#   - ‚úÖ Sistema de backup automatizado no diret√≥rio 'backups/'
#   - ‚úÖ Pol√≠tica de reten√ß√£o: m√°ximo 7 backups (1 semana)
#   - ‚úÖ Nomenclatura com timestamp: YYYYMMDD_HHMMSS
#   - ‚úÖ Limpeza autom√°tica dos backups mais antigos
#
#
# ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
# ‚ïë üöÄ MODO DE USO
# ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
#
#   Executar:    ./dashboard-updater.sh
#
#
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

set -e

DASHBOARD_FILE="DASHBOARD_KPIS.md"
BACKUP_DIR="backups"
BACKUP_FILE="${BACKUP_DIR}/DASHBOARD_KPIS_backup_$(date '+%Y%m%d_%H%M%S').md"
MAX_BACKUPS=7

echo "üîÑ Iniciando atualiza√ß√£o integrada do dashboard..."

# Criar diret√≥rio de backup se n√£o existir
mkdir -p "$BACKUP_DIR"

# Fun√ß√£o para gerenciar pol√≠tica de backups
manage_backup_policy() {
    local backup_dir="$1"
    local max_backups="$2"
    local file_pattern="DASHBOARD_KPIS_backup_*.md"
    
    echo "üóÇÔ∏è  Aplicando pol√≠tica de backups (m√°ximo: $max_backups arquivos)..."
    
    # Contar arquivos de backup existentes
    local backup_count
    backup_count=$(find "$backup_dir" -name "$file_pattern" -type f 2>/dev/null | wc -l)
    
    if [ "$backup_count" -ge "$max_backups" ]; then
        # Calcular quantos arquivos excedentes existem
        local excess_files=$((backup_count - max_backups + 1))
        
        echo "üìÅ Encontrados $backup_count backups. Removendo os $excess_files mais antigos..."
        
        # Remover os arquivos mais antigos
        find "$backup_dir" -name "$file_pattern" -type f -printf '%T@ %p\n' | \
        sort -n | \
        head -n "$excess_files" | \
        cut -d' ' -f2- | \
        while read -r old_backup; do
            echo "üóëÔ∏è  Removendo backup antigo: $(basename "$old_backup")"
            rm -f "$old_backup"
        done
    else
        echo "üìÇ Backups atuais: $backup_count (dentro do limite de $max_backups)"
    fi
}

# Aplicar pol√≠tica de backups antes de criar novo backup
manage_backup_policy "$BACKUP_DIR" "$MAX_BACKUPS"

# Backup do arquivo original com timestamp
cp "$DASHBOARD_FILE" "$BACKUP_FILE"
echo "üíæ Backup criado: $BACKUP_FILE"

# Fun√ß√£o para obter cor do badge baseada no progresso
get_badge_color() {
    local progress=$1
    if [ "$progress" -ge 90 ]; then
        echo "brightgreen"
    elif [ "$progress" -ge 70 ]; then
        echo "green"
    elif [ "$progress" -ge 50 ]; then
        echo "yellow"
    elif [ "$progress" -ge 30 ]; then
        echo "orange"
    else
        echo "red"
    fi
}

# Fun√ß√£o para obter status baseado no progresso
get_status_text() {
    local progress=$1
    if [ "$progress" -ge 90 ]; then
        echo "üü¢ Excelente"
    elif [ "$progress" -ge 70 ]; then
        echo "üü¢ Bom"
    elif [ "$progress" -ge 50 ]; then
        echo "üü° Regular"
    elif [ "$progress" -ge 30 ]; then
        echo "üü° Atrasado"
    else
        echo "üö® Cr√≠tico"
    fi
}

# Fun√ß√£o para extrair progresso de uma issue espec√≠fica
get_issue_progress() {
    local issue_number=$1
    echo "üìä Extraindo progresso da Issue #$issue_number..." >&2
    
    # Obter corpo da issue
    local issue_body
    issue_body=$(gh issue view $issue_number --json body | jq -r '.body')
    
    # Extrair progresso (buscar padr√µes como **Progresso Atual**: ‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 17%)
    local progress
    progress=$(echo "$issue_body" | grep "Progresso Atual" | grep -o "[0-9]\+%" | head -1 | tr -d '%')
    
    # Se n√£o encontrou, buscar por padr√µes alternativos
    if [ -z "$progress" ]; then
        progress=$(echo "$issue_body" | grep -o "‚ñà\+‚ñë\+.*[0-9]\+%" | head -1 | grep -o "[0-9]\+%" | tr -d '%')
    fi
    
    echo ${progress:-0}
}

# Fun√ß√£o para atualizar badge no dashboard
update_dashboard_badge() {
    local area_name="$1"
    local progress="$2"
    local color
    color=$(get_badge_color $progress)
    local status
    status=$(get_status_text $progress)
    
    echo "üîÑ Atualizando badge: $area_name ($progress%)"
    
    # Atualizar badge de progresso
    sed -i "s|üìö \*\*$area_name\*\*.*|üìö \*\*$area_name\*\* \| ![Progress](https://img.shields.io/badge/${progress}%25-${color}) \| $status \|" "$DASHBOARD_FILE"
}

# Fun√ß√£o para atualizar disciplina espec√≠fica
update_discipline() {
    local issue_num="$1"
    local discipline_name="$2"
    # local hours="$3"  # N√£o utilizado pois preservamos a estrutura original
    
    local progress
    progress=$(get_issue_progress $issue_num)
    local color
    color=$(get_badge_color $progress)
    
    echo "üìö Atualizando disciplina: $discipline_name ($progress%)"
    
    # Usar perl para evitar problemas com caracteres especiais no sed
    # Substituir apenas o badge de progresso preservando as demais colunas
    perl -i -pe "s/(.*\*\*\Q$discipline_name\E\*\*.*?\|.*?\|)\s*!\[Progress\]\([^)]+\)(\s*\|.*)/\$1 ![Progress](https:\/\/img.shields.io\/badge\/${progress}%25-${color})\$2/" "$DASHBOARD_FILE"
}

echo "üìà Atualizando progresso das disciplinas individuais..."

# Atualizar disciplinas espec√≠ficas baseadas nas issues
update_discipline "2" "Matem√°tica Aplicada"
update_discipline "3" "Tecnologia de Redes"  
update_discipline "4" "Redes de Computadores Remotas"
update_discipline "5" "Cabeamento Estruturado"
update_discipline "6" "Tecnologias de Roteamento"
update_discipline "7" "Sistema Linux"

echo "üéØ Calculando progresso geral..."

# Calcular progresso acad√™mico geral baseado nas disciplinas
TOTAL_DISCIPLINES=6
ACADEMIC_TOTAL=0

for issue_num in 2 3 4 5 6 7; do
    progress=$(get_issue_progress $issue_num)
    ACADEMIC_TOTAL=$((ACADEMIC_TOTAL + progress))
done

ACADEMIC_AVERAGE=$((ACADEMIC_TOTAL / TOTAL_DISCIPLINES))

echo "üìä Progresso acad√™mico m√©dio: $ACADEMIC_AVERAGE%"

# Atualizar resumo executivo
ACADEMIC_COLOR=$(get_badge_color $ACADEMIC_AVERAGE)
ACADEMIC_STATUS=$(get_status_text $ACADEMIC_AVERAGE)

# Atualizar linha do resumo executivo usando perl - preservando coluna "Pr√≥ximo Milestone"
perl -i -pe "s/(.*üìö \*\*Progresso Acad√™mico\*\*.*?\|)\s*!\[Progress\]\([^)]+\)(\s*\|.*)/\$1 ![Progress](https:\/\/img.shields.io\/badge\/${ACADEMIC_AVERAGE}%25-${ACADEMIC_COLOR})\$2/" "$DASHBOARD_FILE"

# Atualizar timestamp
CURRENT_DATE=$(date '+%d de %B de %Y')
sed -i "s/√öltima atualiza√ß√£o: .*/√öltima atualiza√ß√£o: $CURRENT_DATE/g" README.md
# Atualizar pr√≥xima data de atualiza√ß√£o
sed -i "s/\*\*üìÖ Pr√≥xima atualiza√ß√£o\*\*: .*/\*\*üìÖ Pr√≥xima atualiza√ß√£o\*\*: $(date -d '+1 day' '+%d\/%m\/%Y')/g" "$DASHBOARD_FILE"

echo "‚úÖ Dashboard atualizado com sucesso!"
echo "üìÅ Backup salvo em: $BACKUP_FILE" 
echo "üìä Resumo das atualiza√ß√µes:"
echo "   - Progresso Acad√™mico M√©dio: $ACADEMIC_AVERAGE%"
echo "   - Status: $ACADEMIC_STATUS"
echo "   - Data de atualiza√ß√£o: $CURRENT_DATE"
